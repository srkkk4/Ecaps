一个显然的性质是，对一个子段进行操作可以视为移除了当前子段。

那么问题转化成，删除掉一个子段之后新序列是否合法。

## 10pts

非常简单。

## 30pts

在 $10pts$ 的基础上直接二分区间长度，也秒了。

## $m = 1$

把 $a[l_1:r_1]$ 提取出来，等价于要求整个序列不能有相同的数。

考虑双指针，比较好想。并且会对正解有所启发。

## 60pts

献给常数不好的 $O(n \log n)$ 选手。

[其实就是这道题](https://codeforces.com/contest/1684/problem/F)

考虑双指针（题目就叫 **t**wo-**p**oints），设计一个贡献值。

我们设当前双指针的区间 $[L, R]$：

- 右指针右移，那么减去不在 $[L, R + 1]$ 区间内与 $a_{R+ 1}$ 相等的并且与 $R + 1$ 至少有一个共同区间覆盖的值。
- 左指针右移，那么加上不在 $[L + 1, R]$ 区间内与 $a_{L}$ 相等的并且与 $L$ 至少有一个共同区间覆盖的值。

对于共同区间的处理，我们记 $ml_i, mr_i$ 表示覆盖了 $i$ 的区间的左端点的最小值/右端点的最大值。

这个东西很容易可以跑一遍 前缀$\min$ / 后缀$\max$ 求出。

这样我们就可以在 $m = 1$ 的基础上改一下，随便上点数据结构可以做到 $O(n \log n)$。

常数好其实直接满分了。

## 100pts

如果真的放过 $O(n \log n)$ 显得有点太水了，但是我很菜卡不动，因为读入量太大导致实际表现和 $O(n \log n)$ 的做法不相上下（

或许参考 CSP-S 2024 T3 的多测出法可以在表现上拉开差距，不过这样太不友好了（）

考虑把限制作一个转化，变为 $[lim_i, i]$ 中间不能够出现相同的数，这个转化的正确性显然。

不难发现对于 $i < j, 有 lim_i \le lim_j$，因此我们对 $(lim_{i - 1}, i]$  的一段区间，求出点 $x$ 的限制 $[posl_x, posr_x]$，表示要么选取 $x$ ，要么选区间 $[posl_x, posr_x]$。

那么只需要首先对后缀前缀求区间并，然后每次判断左指针能否左移就行。

现在压力给到求 $posl, posr$ 上，考虑用  `gp_hash_table` 或者 `unordered_map` 离散化，并且开一个 vector 该数出现的位置集合，根据刚刚所提到的性质，一段区间内相同的数映射到vector中的区间一定也是位置递增的。并且会做出贡献的仅有这段区间的左端点和右端点，因此我们就实现了 $O(n)$ 求 $posl$ 和 $posr$。

时间复杂度 $O(n)$。